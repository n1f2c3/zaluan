#进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。
#1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口
#  2：管理、调度进程，并且将多个进程对硬件的竞争变得有序#二 多道技术：    1.产生背景：针对单核，实现并发
#现在得主机一般是多核
#什么是多核
#CPU个数即CPU芯片个数
#什么是cpu得核心数
#是指物理上，也就是硬件上存在着几个核心。比如，双核就是包括2个相对独立的CPU核心单元组，四核就包含4个相对独立的CPU核心单元组
#相对独立得核心
#线程数是一种逻辑的概念，简单地说，就是模拟出的CPU核心数。对于一个CPU，
# 线程数总是大于或等于核心数的。一个核心最少对应一个线程，但通过超线程技术，一个核心可以对应两个线程，也就是说它可以同时运行两个线程。
#PU的线程数概念仅仅只针对Intel的CPU才有用，因为它是通过Intel超线程技术来实现的，最早应用在Pentium4上。如果没有超线程技术，
# 一个CPU核心对应一个线程。所以，对于AMD的CPU来说，只有核心数的概念，没有线程数的概念。
#CPU之所以要增加线程数，是源于多任务处理的需要。线程数越多，越有利于同时运行多个程序，因为线程数等同于在某个瞬间CPU能同时并行
# 处理的任务数。 因此，线程数是一种逻辑的概念，简单地说，就是模拟出的 CPU 核心数。一个核心最少对应一个线程，
# 但英特尔有个超线程技术可以把一个物理线程模拟出两个线程来用，充分发挥 CPU 性能，即一个核心可以有两个到多个
# 线程。
#多核心分为
#|
#|   -----原生多核
#原生多核指得是真正意义上得多核，由AMD提出。每个核心之间都是完全独立得不会造成冲突，
# 即使在高负载状况下，每个核心都能保证自己的性能不受太大的影响，通俗的说，
# 原生多核的抗压能力强，但是需要先进的工艺，每扩展一个核心都需要很多的研发时间。
#|   ------封装多核
#封装多核是只把多个核心直接封装在一起，比如Intel早期的PD双核系列，就是把两个单核直接封装
# 在一起，但两核心只能共同拥有一条前端总线，在两个核心满载时，两个核心会争抢前端总线，导致
# 性能大幅度下降，所以早期的PD被扣上了“高频低能”的帽子，要提高封装多核的性能，在多任务的
# 高压下尽量减少性能损失，只能不断的扩大前端总线的总体大小，来弥补多核心争抢资源带来的性能损
# 失，但这样做只能在一定程度上弥补性能的不足，和原生的比起来还是差了很多，而且后者成本比较高，
# 优点在于多核心的发展要比原生快的多。
#|-----核心（Die）又称为内核，是CPU最重要的组成部分。CPU中心那块隆起的芯片就是核心，
# 是由单晶硅以一定的生产工艺制造出来的，CPU所有的计算、接受/存储命令、处理数据都由核心执行。
# 各种CPU核心都具有固定的逻辑结构，一级缓存、二级缓存、执行单元、指令级单元和总线接口等逻辑单
# 元都会有科学的布局。
#|------双内核
#具备两个物理上的运算内核
#HT技术是超线程技术，是造就了PENTIUM 4的一个辉煌时代的武器，尽管它被评为失败的技术，但是却对P4
# 起一定推广作用，双核心处理器是全新推出的处理器类别；HT技术是在处理器实现2个逻辑处理器，是充
# 分利用处理器资源，双核心处理器是集成2个物理核心，是实际意义上的双核心处理器。
#|-------多核心处理器
#，又称多核心微处理器，是在单个计算组件中，加入两个或以上的独立实体中央处理单元（简称核心，英语：Core）
# 。这些核心可以分别独立地运行程序指令，利用并行计算的能力加快程序的运行速度。只有两个核心的
# 处理器，称为双核心处理器（dual-core processor）。“多核心”通常是对于中央处理器（Ce
# ntral Processing Unit，CPU）而论的，但是某些时候也指数字信号处理器（DSP）和系统芯片（SoC）
# |--------内核和cpu之间有什么关系，内核是cpu得核心，一个CPU可以有多个内核，一个内核只有一个CPU
#    ----CPU的中间就是我们平时称作核心芯片或CPU内核的地方，这颗由单晶硅做
# 成的芯片可以说是电脑的大脑了，所有的计算、接受/存储命令、处理数据都是
# 在这指甲盖大小的地方进行的。
#    ----中央处理器是一块超大规模的集成电路，是一台计算机的运算核心（Core）
# 和控制核心（ Control Unit）。功能主要是解释计算机指令以及处理计算机软件中的数据。
#    ------多核处理器是指在一枚处理器中集成两个或多个完整的计算引擎(内核)。
#|------单核多CPU
#-----那么每一个CPU都需要有较为独立的电路支持，有自己的Cache，而他们之间通过板上的总线进行通信。（一致性问题）
#假如在这样的架构上，我们要跑一个多线程的程序（常见典型情况），不考虑超线程，那么每一个线程就要跑在一个独立的CPU上，
# 线程间的所有协作都要走总线，而共享的数据更是有可能要在好几个Cache里同时存在。这样的话，总线开销相比较而言是很大的，
# 怎么办？那么多Cache，即使我们不心疼存储能力的浪费，一致性怎么保证？
#|------多核单CPU
#那么我们只需要一套芯片组，一套存储，多核之间通过芯片内部总线进行通信，
# 共享使用内存。在这样的架构上，如果我们跑一个多线程的程序，那么线程间
# 通信将比上一种情形更快。
#|----多cpu
#多个CPU常见于分布式系统，用于普通消费级市场的不多，多用于cluster，
# 云计算平台什么的。多CPU架构最大的瓶颈就是I/O，尤其是各个CPU之间的通讯
# ，低成本的都用100M以太网做，稍微好一点的用1000M以太网，再好的就用光纤
# 等等，但无论如何速度和通量都比不上主板的主线。所以多CPU适用于大计算量，
# 对速度（时间）不（太）敏感的任务，比如一些工程建模，或者像SATI找外星人
# 这种极端的，跑上几千年都不着急的。而且多CPU架构更简单清晰，可以用消费
# 级产品简单做数量堆叠，成本上有优势。而多核单CPU则适合对通讯I/O速度要求
# 较快的应用，（相同核数量下）成本上也高一些，好像只有在超级计算机里会用
# 到以万为单位的核心数，普通消费级产品也就是到16核封顶了，因为成本控制的
# 原因。
#|----windows上查看得命令
#在Windows中，在cmd命令中输入“wmic”，然后在出现的新窗口中分别输入
# “cpu get Name”,“cpu get NumberOfCores”,
# “cpu get NumberOfLogicalProcessors”
# 即可查看物理CPU数、CPU核心数、线程数。
#“systeminfo”，以下信息表示物理CPU有两个
#如何利用systeminfo获取主机得漏洞信息
import multiprocessing
import time

def worker_1(interval):
    print("work_1")

    time.sleep(11000);
    print("endork_1")
def worker_2(interval):
    print("work_2")
    time.sleep(11000);
    print("endork_2")

def worker_3(interval):
        print("work_3")
        time.sleep(11000);
        print("endork_3")

def worker_4(interval):
            print("work_4")
            time.sleep(11000);
            print("endork_4")

if __name__=="__main__":
    p1=multiprocessing.Process(target=worker_1,args=(2,))
    p2 = multiprocessing.Process(target=worker_2, args=(3,))
    p3 = multiprocessing.Process(target=worker_3, args=(4,))
    p4 = multiprocessing.Process(target=worker_4, args=(5,))
    p5 = multiprocessing.Process(target=worker_4, args=(5,))
    p6 = multiprocessing.Process(target=worker_4, args=(5,))
    p7 = multiprocessing.Process(target=worker_4, args=(5,))
    p8 = multiprocessing.Process(target=worker_4, args=(5,))
    p9 = multiprocessing.Process(target=worker_4, args=(5,))
    p1.start()
    p2.start()
    p3.start()
    p4.start()
    p5.start()
    p6.start()
    p7.start()
    p8.start()
    p9.start()

    print("The number of CPU is:"+str(multiprocessing.cpu_count()))
    for p in multiprocessing.active_children():
        print("child   p.name:"+p.name+"\tp.id"+str(p.pid))
    print("end!!!!");
